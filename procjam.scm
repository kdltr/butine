(use color cairo miscmacros numbers)

(load "utils.scm")

(define 2pi (* 2 pi))
(define pi/2 (/ pi 2))
(define pi/3 (/ pi 3))
(define pi/4 (/ pi 4))

(define (color->cairo c)
  (map (lambda (x) (exact->inexact (/ x 255))) (color->sRGB c)))

(define (color:rotate-hue color degrees)
  (let* ((LCh (color->L*C*h color))
         (hue (+ (caddr LCh) degrees)))
        (L*C*h->color
          (append (take LCh 2)
                  (list (cond ((< hue 0.0)
                               (let incr ((h hue))
                                 (if (>= h 0.0) h (incr (+ 360.0 h)))))
                              ((> hue 360.0)
                               (let reduce ((h hue))
                                 (if (<= h 360.0) h (reduce (- h 360.0)))))
                              (else
                                hue)))))))

(define (color:scale-chroma color factor)
  (let* ((LCh (color->L*C*h color))
                 (chroma (* (cadr LCh) factor)))
        (L*C*h->color (cons (car LCh) (cons chroma (cddr LCh))))))

(define (color:triad c)
  (list (color:rotate-hue c -120) c (color:rotate-hue c 120)))

(define (color:complement c)
  (color:rotate-hue c 180))

(define (random-color)
  (color:sRGB (pseudo-random-integer 255)
              (pseudo-random-integer 255)
              (pseudo-random-integer 255)))

(load "gen.scm")

(define base-color (random-color))
(print (color->cairo base-color))

(define ww/3 (round (/ ww 3)))
(define ww/2 (round (/ ww 2)))
(define wh/2 (round (/ wh 2)))

(define (random-flower)
  (let* ((center-color (color:L*C*h (between 70 100)
                                    (between 80 100)
                                    (between 0 360)))
         (comp (color:complement center-color))
         (a (between 20 30))
         (pts1 (color:rotate-hue comp (- a)))
         (pts2 (color:rotate-hue comp a))
         (angle-div1 (between 1 5))
         (angle-div2 (between 1 5))
         (len-div1 (between 3 8))
         (len-div2 (between 3 8))
         (len-num1 (between 1 (quotient (between len-div1 (+ len-div1 5))
                                        2)))
         (len-num2 (between 1 (quotient (between len-div2 (+ len-div2 5))
                                        2)))
         )
  `((center-color . ,center-color)
    (center-size . ,(pseudo-random-real))
    (poly . ,(between 3 8))
    (angle . ,(* 2pi (pseudo-random-real)))
    (petals (,pts1 ,(/ len-num1 len-div1)
                   ,(/ (- len-div1 len-num1) len-div1)
                   ,(/ pi angle-div1)
                   ,(/ pi (* 2 angle-div1)))
            (,pts2 ,(/ len-num2 len-div2)
                   ,(/ (- len-div2 len-num2) len-div2)
                   ,(/ pi angle-div2)
                   ,(/ pi (* 2 angle-div2)))))))

#;(set-pseudo-random-seed! (random-bytes))
(set-pseudo-random-seed! #${3c7ed09c3a86bb8c35cb8a35ee5a30a5e1fbc23b928c9596e605b54abc9dc09b3bf4d8feac0c97df97ec8f0602c3dc48cf6170d92a7485333a6798f1d1f2eef1a492a16a639141011ce1ac45923f0a83c962985d656e78292b12e96ee888185967151127bcd3f419d450a5e2e9921b0ebb9b7ae9e6076446fa13beb32d7420bf})
(define *flowers*
  (list-tabulate 40 (lambda (i) (cons i (random-flower)))))

(define (show-frame)
  (set! base-color (color:rotate-hue base-color (/ dt 10)))
  (apply set-source-rgb! ctx (color->cairo (color:L*C*h 50 0 0)))
  (paint! ctx)
  
  #;(let ((triad1 (color:triad base-color))
        (triad2 (color:triad (color:complement base-color))))
    (save! ctx)
    (color-line! triad1)
    (translate! ctx 0 wh/2)
    (color-line! triad2)
    (restore! ctx))
  
  (for-each
    (lambda (i+f)
      (save! ctx)
      (let* ((i (car i+f))
             (f (cdr i+f))
             (x (modulo i 10))
             (y (quotient i 10)))
        (translate! ctx
                    (+ (/ ww 20) (* x (/ ww 10)))
                    (+ (/ wh 8) (* y (/ wh 4))))
        (scale! ctx 1.5 1.5)
        (rotate! ctx (alist-ref 'angle f))
        (flower! f))
    (restore! ctx))
    *flowers*)
  
  #;(let ((n 30))
      (translate! ctx ww/2 wh/2)
      (scale! ctx 9 9)
      (flower! (cdr (list-ref *flowers* n))))

  )

(define (color-line! colors)
  (save! ctx)
  (for-each
    (lambda (c)
      (apply set-source-rgb! ctx (color->cairo c))
      (rectangle! ctx 0 0 ww/3 wh/2)
      (fill! ctx)
      (translate! ctx ww/3 0))
    colors)
  (restore! ctx))

(define (flower! fl)
  (let ((poly (alist-ref 'poly fl))
        (pts (alist-ref 'petals fl)))
    (scale! ctx 10 10)
    (set-source-rgba! ctx 0 1 0 0.8)
    (for-each
      (lambda (p)
        (apply petals poly p)
        (rotate! ctx (/ pi poly)))
      pts)
    (center (alist-ref 'center-size fl)
            (alist-ref 'center-color fl)
            poly)
  ))
  
(define (center size color n)
  (let ((angle (/ 2pi n))
        (base (make-polar size 0)))
    (dotimes (i (add1 n))
      (let ((angle (* i angle))
            (angle2 (* 1/2 angle)))
        (let ((ctlpt (make-polar (* (magnitude base) 1.1) ;; TODO
                                 (- angle angle2)))
              (endpt (make-polar (magnitude base) angle)))
          #;(vec-curve-to! ctx ctlpt ctlpt (make-polar (magnitude base)
                                                     angle))
          (line-to! ctx (real-part endpt) (imag-part endpt)))))
    (apply set-source-rgb! ctx (color->cairo color))
    (fill! ctx)))

(define (vec-curve-to! ctx v1 v2 v3)
  (curve-to! ctx
             (real-part v1) (imag-part v1)
             (real-part v2) (imag-part v2)
             (real-part v3) (imag-part v3)))

(define (petals n color near far near-angle far-angle)
  (let* ((phi (/ 2pi n)))
    (dotimes (i n)
      (let* ((v (make-polar (+ 2.2
                               (* 1/11 (sin (+ i (* 12 (/ now 3000))))))
                            (+ (* i phi)
                               (* 1/20 (cos (- i (* 11 (/ now 3000))))))))
             (v2 (make-polar (* (magnitude v) near)
                             (+ (angle v) near-angle)))
             (v3 (make-polar (* (magnitude v) far)
                             (+ (angle v) far-angle)))
             (v4 (make-polar (* (magnitude v) near)
                             (- (angle v) near-angle)))
             (v5 (make-polar (* (magnitude v) far)
                             (- (angle v) far-angle))))
        (move-to! ctx 0 0)
        (vec-curve-to! ctx v2 v3 v)
        (vec-curve-to! ctx v5 v4 0)
        (let ((p (pattern-create-radial 0 0 1 0 0 2.2)))
          (apply pattern-add-color-stop-rgb!
                 p 0(color->cairo (color:scale-chroma color 0.3)))
          (apply pattern-add-color-stop-rgb!
                 p 1 (color->cairo color))
          (set-source! ctx p)
          (fill! ctx)
          (pattern-destroy! p))
    )))
  )